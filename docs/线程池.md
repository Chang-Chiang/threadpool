# 线程池

## 背景

> + 为什么需要线程池？
> + 线程池中线程的数量由什么决定，是不是越多越好？
> + 并发与并行的概念？
> + 什么叫 I/O 密集型、CPU 密集型？
> + 线程的上下文切换？

### 多线程的优势

### 为什么需要线程池

线程的创建和销毁都是非常耗费系统资源的操作，【展开讲】pthread 创建线程首先需要从用户空间切换至内核空间，在进程控制块为线程分配线程内核栈、页目录、页表、描述地址空间的相应数据结构【创建线程需要在内核做很多事情】，在内核空间做完这些事情后又需要切换至用户空间。在服务执行的过程中，如果业务量比较大，实时地去创建、销毁线程，会导致系统的实时性能降低，业务的处理能力也会降低。

线程池通过在服务进程启动刚开始，创建好线程池里面的线程，当业务流量到来需要分配线程时，直接从线程池获取一个空闲线程执行任务即可，任务执行完成后，也不去销毁线程，而是把线程归还到线程池中继续给后续任务提供服务。减少了在服务执行过程中线程创建和销毁所带来的系统性能消耗。

### 线程池的数量？

+ 是不是越多越好
+ 多少个比较好
+ fixed 模式与 cached 模式设置线程池数量

### 并发与并行

### I/O 密集型、CPU 密集型



## 线程同步

> 

线程同步分为==线程互斥==与==线程通信==。分析一段代码能否在多线程环境下执行，主要是看这段代码是否存在==竞态条件==（代码片段在多线程环境下执行，随着线程的调度顺序不同，而得到不同的运行结果），存在竞态条件的代码段称作==临界区代码段==，为了保证临界区代码段不出现竞态条件，则需要保证临界区代码段的==原子操作==。如果这段代码在多线程环境下不存在竞态条件，则称这段代码段是==可重入==的；如果这段代码在多线程环境下存在竞态条件，则称这段代码段是不可重入的。

### 线程互斥

+ 互斥锁
  + 悲观锁
  + 乐观锁
  + CAS 
+ atomic 原子类型

### 线程通信

线程互斥研究的是多线程的相同代码块，线程通信研究的是多线程的不同代码块

生产者消费者模型 是 描述线程通信的一种应用场景，**不要回答成是设计模式！！！**

+ 条件变量 condition_variable，C++11 有提供

  wait 做两件事情，改变线程运行状态 + 释放锁

+ 信号量 semaphore，C++20 才在语言层面提供

  描述互斥锁和信号量。PV 操作



## 整体架构

使用方式

```c++
ThreadPool pool;
pool.setMode(...);
poll.start();

Result result = pool.submitTask(concreteTask);
result.get.Cast<结果类型>()
```

