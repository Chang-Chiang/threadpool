# 整体架构设计

![threadpool](./assets/threadpool.jpg)

## 提供给用户的接口

```c++
ThreadPool pool;                     // 定义线程池
pool.setMode(PoolMode::MODE_CACHED); // 设置线程池工作模式
pool.start(2);                       // 启动线程池（线程池内线程数量） 

// 用户自定义任务类，调用线程池接口向线程池提交任务
Result res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));
```

## 线程池工作流程

1. 该 repo 线程池包含：线程队列 + 任务队列；
2. 用户向线程池提交任务，放于线程池的任务队列中；
3. 线程池的线程队列从任务队列中取任务执行；
4. 在 2、3 这个过程中，用户作为生产者向任务队列生产任务，线程队列作为消费者从任务队列中取任务消费，构成生产者消费者模型

## 技术栈分析

- 线程队列使用 `vector` 容器，可进行动态扩容；任务队列使用 `queue` 容器
- 用户向任务队列提交任务，线程队列从任务队列中取任务，需保证任务队列的原子操作。用到线程同步中的线程互斥操作，对任务队列进行加锁访问
- 用户与线程队列构成生产者消费者模型，用户提交任务时（生产）通知线程队列从任务队列中取任务（消费）。用到线程同步中的线程通信操作，使用条件变量、信号量
- 用户自定义的任务类继承自抽象任务类，重写自定义任务类的方法时，实现用户自定义的任务处理。继承中虚函数的多态
- 用户向线程池的任务队队列提交任务后，线程队列里的线程执行任务，返回值取决于用户定义的任务类。线程执行的返回值继承自 `Any` 类，继承时多态